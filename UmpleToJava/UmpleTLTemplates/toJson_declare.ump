class UmpleToJava {
  toJson_helper <<!<</*toJson_helper*/>>
  public boolean toJsonHelper(StringBuilder toJsonOutput, HashSet<Object> visitedList, int nestLevel, boolean atConcreteClass){
      
      String indent = "  ".repeat(nestLevel);
      boolean alreadyVisited = false;
      boolean haveOutputItem = false;
      
      <<#String customToJsonPrefixCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("before","toJsonHelper"));
	  String customToJsonPostfixCode = GeneratorHelper.toCode(uClass.getApplicableCodeInjections("after","toJsonHelper"));
	  if (customToJsonPrefixCode != null) 
	  {
		  append(realSb, "\n{0}",GeneratorHelper.doIndent(customToJsonPrefixCode, "    "));
	  }
	  if (customToJsonPostfixCode != null) 
	  {
		  append(realSb, "\n{0}",GeneratorHelper.doIndent(customToJsonPostfixCode, "    "));
	  }
      String ret = "";
	  LinkedList<String> displayedAttributes = new LinkedList<String>();
	  LinkedList<String> nameOfAttributes = new LinkedList<String>();
	  LinkedList<String> displayedPrimitives = new LinkedList<String>();
	  LinkedList<String> nameOfPrimitives = new LinkedList<String>();
	  List<String> keys = new ArrayList<String>();
	  List<String> reflexiveNames = new ArrayList<String>();
	  List<String> reflexive = new ArrayList<String>();
	  for(String k: uClass.getKey().getMembers())
		  keys.add(k);
	  for(Attribute av: uClass.getAttributes())
	  {
	      
		  if(!av.getIsList()&&!"internal".equals(av.getModifier())&&!"const".equals(av.getModifier())&&("String".equals(av.getType())||"int".equals(av.getType())||"Integer".equals(av.getType())||"boolean".equals(av.getType().toLowerCase())||"float".equals(av.getType())||"Float".equals(av.getType())||"double".equals(av.getType())||"Double".equals(av.getType())||"byte".equals(av.getType())||"Byte".equals(av.getType())||"char".equals(av.getType())||"Character".equals(av.getType())||"long".equals(av.getType())||"Long".equals(av.getType())||"short".equals(av.getType())||"Short".equals(av.getType())))
		  {
			  if(av.getIsAutounique() || keys.contains(av.getName())){
				  nameOfPrimitives.addFirst(av.getName());
				  displayedPrimitives.addFirst(gen.translate("getMethod",av)+"()");
			  }
			  else {
				  nameOfPrimitives.addLast(av.getName());
				  displayedPrimitives.addLast(gen.translate("getMethod",av)+"()");
			  }
		  }
		  else if(!av.getIsList()&&!"const".equals(av.getModifier())&&!"internal".equals(av.getModifier()))
		  {
			  if(av.getIsAutounique() || keys.contains(av.getName())){
				  nameOfAttributes.addFirst(av.getName());
				  displayedAttributes.addFirst(gen.translate("getMethod",av)+"()");
			  }
			  else {
				  nameOfAttributes.addLast(av.getName());
				  displayedAttributes.addLast(gen.translate("getMethod",av)+"()");
			  }
		  }
	  }
	  for(AssociationVariable av: uClass.getAssociationVariables())
	  {
	    
		  reflexiveNames.add(av.getName());
          reflexive.add(gen.translate("getMethod",av)+"()");
	  }
	  #>>
    if(atConcreteClass) {
      // This will not be true in a super call; output header
      toJsonOutput.append(indent+"\'"+this.toString().split("@")[0]+ "\' : {\n"+indent+  "\'umpleObjectID\' : "+System.identityHashCode(this));

      // Check if we have already visited this object. If so we will not output details
      alreadyVisited = visitedList.contains(this);
      if(!alreadyVisited) {
        visitedList.add(this);
      }
    }
    
    // There is no superclass of this class
    <<#boolean hasSuperClass =uClass.hasExtendsClass();#>>
    if(alreadyVisited) {
      toJsonOutput.append("\\n");
    }
    else {
      // Check if this class has a superclass. If it does, we make a call to output superclass content 
      // This will keep calling super so the topmost attributes and associations appear first
      <<#if(hasSuperClass){#>>
        haveOutputItem = super.toJsonHelper(toJsonOutput, visitedList, nestLevel, false);
      <<#}#>>
      // When an object has not already been visited, output its details
      toJsonOutput.append("\n");
      
      // When an object has not already been visited, output its details
      toJsonOutput.append(indent);
      toJsonOutput.append("<<#
        for (int m1=0;m1<displayedPrimitives.size();m1++){
          if (m1==(displayedPrimitives.size()-1)){
            realSb.append("\'" + nameOfPrimitives.get(m1) + "\'" + " : "+  displayedPrimitives.get(m1)+"\\n");
          }
          else{
            realSb.append("\'" + nameOfPrimitives.get(m1) + "\'" + " : "+  displayedPrimitives.get(m1)+",\\n"); 
          }
        }
        //ret += "m2="+displayedAttributes.size();
        //for(int m2=0;m2<displayedAttributes.size();m2++)
	    //{             
	      
		  //ret += "\"  \" + " + "\"" + nameOfAttributes.get(m2) + "\" + \":\" + (" + displayedAttributes.get(m2) + " != null ? !" + displayedAttributes.get(m2) + ".equals(this)  ? " + displayedAttributes.get(m2) + ".toString().replaceAll(\"  \",\"    \") : \"this\" : \"null\")";
	    //}
	    for(int m3=0;m3<reflexive.size();m3++){       
	      if(m3==(reflexive.size()-1)){
	        realSb.append("---\'" + reflexiveNames.get(m3) + "\'" + " : "+  reflexive.get(m3)+",\\n"); 
	      }
	      else{
	      //"---" is for debug, will remove later
	        realSb.append("---\'" + reflexiveNames.get(m3) + "\'" + " : "+  reflexive.get(m3)+"\\n"); 
	      }
         
	    }  
	    realSb.append(ret);  
      #>>");

    }

    // Finalize the output of the concrete class
    if(atConcreteClass) {
      if(!alreadyVisited) {
        toJsonOutput.append("\n");
      }
      toJsonOutput.append(indent+"}");
    }
    haveOutputItem = true;
    

  return haveOutputItem;
  }

  !>>  
  
  toJson_declare <<!<</*toJson_declare*/>>
  /** 
  * Generate Json for this object and connected objects visited objects to enable avoidance of infinite loops
  *
  * @param toJsonOutput  Output is aded to this as the network of objects is traversed
  * @param visitedList  Every concrete object visited is added so we don't re-outpu
  * @param nestLevel    As we output deeper objects, indent them more
  * @param atConcreteClass false when we are recursing to a superclass
  *     so we get the superclass data
  * @return whether or not anything was output (so we can tell whether we need to output a comma)
  */  
  public String toJson()
  {
    HashSet<Object> visitedList = new HashSet<Object>();
    StringBuilder toJsonOutput = new StringBuilder();
    toJsonOutput.append("{\n");
    this.toJsonHelper(toJsonOutput, visitedList,1,true);
    toJsonOutput.append("\n}");
    return(toJsonOutput.toString());
  }
  !>>
    
}
